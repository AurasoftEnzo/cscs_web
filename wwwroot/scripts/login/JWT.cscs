//----------------------------------
//-- JWT ---------------------------

// Simple HMAC-like hash using secret (simulate HMAC-SHA256 as best as possible)
function SignToken(payload, secret) {
    // Combine payload + secret
    toSign = payload + "." + secret;
    // In real app: use SHA256 hash � here we use simple Base64 as placeholder
    // You can replace this with actual hashing if cscs_web supports it
    return Base64Encode(toSign);
}

// Encode string to Base64
function Base64Encode(str) {
    // Placeholder � assume cscs_web has Base64 or use external JS
    return str; // In real app: use proper encoding
}

// Create JWT-like token
function CreateJwtToken(companyCode, fiscalYear, databaseName, userCode, userName, userRole) {
    issuedAt = Now("yyyy-MM-dd HH:mm:ss");
    payload = "company=" + companyCode +
              "&year=" + fiscalYear +
              "&db=" + databaseName +
              "&user=" + userCode +
              "&name=" + userName +
              "&role=" + userRole +
              "&iat=" + issuedAt;


    signature = SignToken(payload, ReadConfig("JwtSecretKey"));
    return Base64Encode(payload) + "." + signature;
}

// Verify token signature
function VerifyJwtToken(token) {
    // parts = Split(token, ".");
    parts = token.Split(".");
    
    print("Token parts: " + parts);

    // if (Size(parts) != 2) return null;
    if (Size(parts) != 2){
        return null;
    } 

    payloadB64 = parts[0];
    signature = parts[1];

    payload = Base64Decode(payloadB64);
    expectedSignature = SignToken(payload, ReadConfig("JwtSecretKey"));

    if (signature != expectedSignature){
        return null;
    }
    
    // Parse payload
    params = ParseQueryString(payload);
    issuedAt = params["iat"];

    // Check if token is older than 24h (optional)
    // For now, just return claims
    return params;
}

function Base64Decode(str) {
    return str; // Reverse of encode � implement if needed
}

function ParseQueryString(q) {
    pairs = q.Split("&"); // a=1&b=2&c=3
    dict = {};
    for(i = 0; i < Size(pairs); i++) {
        kv = pairs[i].Split("=");
        if (Size(kv) == 2) {
            dict[kv[0]] = kv[1];
        }
    }
    return dict;
}



//-- Validate token -----------------------

function RequireAuth(args) {
    token = GetSession(args, "AuthToken");
    if (token == null){
        return null;
    }

    claims = VerifyJwtToken(token);
    if (claims == null){
        return null;
    }

    // // Check inactivity (e.g., 24h max session)
    // lastActivityStr = GetSession(args, "LastActivity");
    // if (lastActivityStr != null) {
    //     lastActivity = ParseDate(lastActivityStr);
    //     now = CurrentDate();
    //     diffMs = (now.getTime() - lastActivity.getTime());
    //     if (diffMs > 24 * 60 * 60 * 1000) { // 24 hours
    //         return null;
    //     }
    // }

    return claims;
}